<?xml version="1.0" encoding="utf-8" ?>
<ORM-Mapping assembly="" namespace="">
  <!--name代表类的属性名，Column对应table的列名，table表名称,class代表属性类-->
  <class name="" table="">
    <identity name="2" column=""/>
    <!--自增长，默认类型int，必须有-->
    <property name="1" column="" type=""/>
    <!--一对一关联有主键和外键映射，有单向和双向引用，如果使用数据库自动生成策略无法保证-->
    <one-to-one name="" class="" refercolumn="" twoway="true"/> 
    <many-to-many name="" key="" class="" colunm="" table=""  twoway="true"/>
    <!--在name的class类型对象映射的表有一个column写入本类id-->
    <one-to-many name="" class="" column="" twoway="true"/>
    <!--从name的class类型对象取出id写入本对象映射表的column列-->
    <many-to-one name="" column="" class=""/>
    <!--在name的class类型对象取出id写入本对象映射表的column列
    本质上一对一主键和一对一外键是相同类型，这里只是为了确认哪张表负责保存引用-->
    <foregin-one name="" column="" class="" />
    <!--代表多对多的写入端-->
    <!--one-to-one,one-to-many只代表引用，表示取得对象时必须取得对象引用-->
  </class>
</ORM-Mapping>
<!--默认情况下，只要包含了类的引用关系的都被自动导出成对象，由于在对象里为了方便访问
和更新数据到数据库，集合的子项对象会带有对拥有它的类的引用，构成双向关联，这种关联可能
会导致死循环加载，因此在orm自身内建立一层缓存，使用缓存保持各个对象，而上层得到的只是引用
在插入新的对象后，该对象也会被自动载入缓存，方便二次访问。
    对象和数据库记录依赖唯一的id关联，id默认由数据库生成，也就是插入后才能得到id。
在此之前，对象间的关系依赖内存系统关联，同时也考虑了已经获得唯一id的更新方法
    对于四种关系的插入查找更新的讨论：
    1.一一对应 一个对象带有另一个对象的引用并且唯一
查询时联合查询取出，更新时除更新本类属性之外，同时更新被引用对象的id。
插入时先插入被引用对象，或者判断是否存在，然后返回一个id后，再插入对象，
或者先插入该对象，查询是否被引用对象已经在数据库存在，然后插入后更新guid（前提是允许guid为空）
删除时只删除本对象，待数据库自动删除
  2.多对一 对象被包含在另一个对象的集合里
查询时取出被引用的对象，被引用的对象随即自动建立同引用对象的集合关系
插入时先插入被引用对象，否则会报错——考虑自动处理的原则，检查对象id是否存在，然后决定是否先插入对象
  3.多对多 对象间的引用关系被储存在一张额外的表中
更新时，联合查询引用关系并删除该记录
  假如，guid由数据库生成，同时类之间存在循环引用： 比如一个对象在插入前检查到无法获取所引用对象的id，因为该被引用对象未插入，
因此将该对象先插入，但是该被引用对象可能包含了对源对象的循环引用，于是又会检查到源对象的id无法获得
  因此插入过程必须先进行，不完全的字段存入，然后返回一个guid，保存到cache，让被引用对象循环引用时认为源对象已经插入，然后就
  停止了循环引用，然后源对象继续更新guid。
-->