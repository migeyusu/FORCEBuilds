下一步改进：
1.利用对象间关系自动建库，修库（注意异常)
2.添加级联关系，比如从某一个集合中删除后，是在数据库置空值还是删除
3.利用对象间关系实现自动删除内存间关系，比如一个多对多关系如果存在双向引用，
当甲对象去除了和乙对象间的联系，自动从乙对象中找到反向引用去除相应的关系
4.缓存和数据库的同步：数据库中的级联删除能反应到缓存中
目前我的orm只能做到级联保存，级联删除还未支持，导致数据库中删除的内容依然会存在缓存中
所以如果长期运行并且有大量数据新建和删除，一定会导致内存占用率上升。

版本更新 2018.8.11
彻底更改同步策略：不再允许自动刷新更新到数据库，所有更新都以事务块形式提交（之前是分成多个事务行）
设想两种可能的使用情况：
1.单例使用Field：此时由于map的存在，所有的同id对象只会存在一个，如果服务层存在多线程情况，则需要处理并发冲突。
由于map可以完全等同数据库，此时事务的实现将被转移到内存中，同时服务层必然使用悲观锁，因为乐观锁需要副本。
假设利用代理为每个线程构建副本，对于直接引用的属性，这是可能的，但是对于集合属性，根本不可能代理他的行为，
服务层不得不使用锁以解决并发冲突，而为了实现事务特性，这个集合必须在整个事务的开始就被手动锁定，那么自动的内存事务的实现也就无从谈起了。
所以，只能实现日志记录更改的特性，而不可能在单例下代替业务层实现内存事务。
2.多例使用Field：map只用于防止循环加载，副本存在于每个线程，内存膨胀可由延迟加载缓解。可代为实现乐观离线锁，日志的作用也发挥出来了。
尤其是集合，可以精确地更新关系，对于EntityFramework，由于没有使用IObservable，更新关系的性能开销是很大的。
同时EF依赖反向引用以检测关系更改，这在本orm是不需要的。
所以简单描述工作方式：
1.多例生成field
2.记录下model的修改
3.提交并同数据库的值比较
4.完成事务

2019.8
最小化更改：
过去的开发思路贪大求全，各种逻辑错误频出，决定从头起更改版本：
1.先做出一个最小化实现版本，必须保持缓存透明和数据库透明
2.使用pipeline模型实现处理
3.尽可能实现EF的基础功能

2019.8.13
需要实现的功能
1.object cache refresh/sync 
2.当navigation property更改时，同时更新反向引用：
在ef中，不仅当savechanges，在更改了A的外键引用到B后再次查询时，ef会主动调整引用关系，在B的引用集合中包括A

change detection：
通常三种：1,使用snapshot自动隐式检查 2,使用snapshot自动检查显示标记对象 3, 使用notify对象
直接引用的notify可以用代理实现，但是对于集合的更改检测无能为力，在之前的版本让集合对象必须实现集合变更通知，考虑代理集合类，只要集合类的方法被调用了，就被标记为脏并进行检查
强壮的解释器（包含输入的规范——引申到需要关系视图的规范化，对各种常见性能优化的支持，加入缓存）
