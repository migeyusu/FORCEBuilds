下一步改进：
1.利用对象间关系自动建库，修库（注意异常)
2.添加级联关系，比如从某一个集合中删除后，是在数据库置空值还是删除
3.利用对象间关系实现自动删除内存间关系，比如一个多对多关系如果存在双向引用，
当甲对象去除了和乙对象间的联系，自动从乙对象中找到反向引用去除相应的关系
4.缓存和数据库的同步：数据库中的级联删除能反应到缓存中
目前我的orm只能做到级联保存，级联删除还未支持，导致数据库中删除的内容依然会存在缓存中
所以如果长期运行并且有大量数据新建和删除，一定会导致内存占用率上升。

版本更新 2018.8.11
彻底更改同步策略：不再允许自动刷新更新到数据库，所有更新都以事务块形式提交（之前是分成多个事务行）
设想两种可能的使用情况：
1.单例使用Field：此时由于map的存在，所有的同id对象只会存在一个，如果服务层存在多线程情况，则需要处理并发冲突。
由于map可以完全等同数据库，此时事务的实现将被转移到内存中，同时服务层必然使用悲观锁，因为乐观锁需要副本。
假设利用代理为每个线程构建副本，对于直接引用的属性，这是可能的，但是对于集合属性，根本不可能代理他的行为，
服务层不得不使用锁以解决并发冲突，而为了实现事务特性，这个集合必须在整个事务的开始就被手动锁定，那么自动的内存事务的实现也就无从谈起了。
所以，只能实现日志记录更改的特性，而不可能在单例下代替业务层实现内存事务。
2.多例使用Field：map只用于防止循环加载，副本存在于每个线程，内存膨胀可由延迟加载缓解。可代为实现乐观离线锁，日志的作用也发挥出来了。
尤其是集合，可以精确地更新关系，对于EntityFramework，由于没有使用IObservable，更新关系的性能开销是很大的。
同时EF依赖反向引用以检测关系更改，这在本orm是不需要的。
所以简单描述工作方式：
1.多例生成field
2.记录下model的修改
3.提交并同数据库的值比较
4.完成事务